"use strict";(self.webpackChunkdatalayer_docs=self.webpackChunkdatalayer_docs||[]).push([[3017],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),f=r,h=u["".concat(c,".").concat(f)]||u[f]||d[f]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=f;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},6279:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={id:"fees",title:"Fees",position:5},o=void 0,s={unversionedId:"Learn/Concepts/fees",id:"Learn/Concepts/fees",title:"Fees",description:"\x3c!--",source:"@site/docs/Learn/Concepts/Fees.md",sourceDirName:"Learn/Concepts",slug:"/Learn/Concepts/fees",permalink:"/Learn/Concepts/fees",draft:!1,tags:[],version:"current",frontMatter:{id:"fees",title:"Fees",position:5},sidebar:"defaultSidebar",previous:{title:"TransmitManager",permalink:"/Learn/Components/TransmitManager"},next:{title:"Tracking Messages & Packets",permalink:"/Learn/Concepts/learn-tracking"}},c={},l=[{value:"Estimating Fees",id:"estimating-fees",level:3},{value:"Estimating Fees on-chain",id:"estimating-fees-on-chain",level:3},{value:"How to fetch fee estimate",id:"how-to-fetch-fee-estimate",level:4},{value:"Minimum Fees",id:"minimum-fees",level:3},{value:"Fee Collection",id:"fee-collection",level:3}],p={toc:l},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Plugs need to pay a fee for getting messages included in packets, verified on the destination chain and then executed."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Breakdown of fees")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Fee"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Transmission Fees"),(0,r.kt)("td",{parentName:"tr",align:null},"Fees paid to Transmitters for sealing packets on the source chain and proposing packets on the destination chain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Switchboard Fees"),(0,r.kt)("td",{parentName:"tr",align:null},"Fees paid to Watchers for verifying the validity of a packet on the destination chain.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Execution Fee"),(0,r.kt)("td",{parentName:"tr",align:null},"Fees paid to Executors for executing the message payload on the destination chain")))),(0,r.kt)("h3",{id:"estimating-fees"},"Estimating Fees"),(0,r.kt)("p",null,"Fees can be estimated off-chain using the ",(0,r.kt)("a",{parentName:"p",href:"/dev-resources/APIReference/estimate-fees"},"Fee Estimation API"),". The API calculates the total fee to be sent while sending a message and also returns a breakdown of each fee component."),(0,r.kt)("h3",{id:"estimating-fees-on-chain"},"Estimating Fees on-chain"),(0,r.kt)("p",null,"Sending a cross-chain message requires the message to be verified and executed on the destination chain and the fees for this need to be calculated with the destination chain ",(0,r.kt)("inlineCode",{parentName:"p"},"gasPrice"),". But the gasPrice of the destination chain is not known on the source chain. To enable this calculation, Socket maintains an siblingChain gas fee mapping on the ExecutionManager, TransmitManager and Switchboards. These fees are updated periodically by off-chain agents with the ",(0,r.kt)("inlineCode",{parentName:"p"},"FEES_UPDATER_ROLE")),(0,r.kt)("h4",{id:"how-to-fetch-fee-estimate"},"How to fetch fee estimate"),(0,r.kt)("p",null,"Plugs can use ",(0,r.kt)("a",{parentName:"p",href:"/dev-resources/Interfaces/ISocket"},"ISocket")," to call ",(0,r.kt)("inlineCode",{parentName:"p"},"getMinFees")," method on Socket. This method takes the payload execution gasLimit, destination chain ID, payload size and plug address as input and calculates the total fee. This enables Plugs to be completely on-chain and not rely on any off-chain services for fee calculation or to interact with Socket. "),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getMinFees")," returns the totalFee, which is to be sent in the native token of the chain when calling ",(0,r.kt)("inlineCode",{parentName:"p"},"outbound")," on Socket. "),(0,r.kt)("h3",{id:"minimum-fees"},"Minimum Fees"),(0,r.kt)("p",null,"Socket calculates the minimum fee to ensure the delivery and execution of the message. Plugs can pay a premium on this fee to ensure their message always gets included. This is relevant particularly in case of gasPrice hikes on the destination chain."),(0,r.kt)("h3",{id:"fee-collection"},"Fee Collection"),(0,r.kt)("p",null,"Fees are collected in their respective contracts for each type of fee. These fees are later withdrawn by off-chain actors (Transmitters, Watchers, Executors)."))}d.isMDXComponent=!0}}]);