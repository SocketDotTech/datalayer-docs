"use strict";(self.webpackChunkdatalayer_docs=self.webpackChunkdatalayer_docs||[]).push([[6361],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),d=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(c.Provider,{value:n},e.children)},l="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),l=d(t),h=i,g=l["".concat(c,".").concat(h)]||l[h]||p[h]||r;return t?a.createElement(g,s(s({ref:n},u),{},{components:t})):a.createElement(g,s({ref:n},u))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=h;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[l]="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=t[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},2875:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=t(7462),i=(t(7294),t(3905));const r={},s=void 0,o={unversionedId:"dev-resources/Interfaces/ISocket",id:"dev-resources/Interfaces/ISocket",title:"ISocket",description:"Required by Plugs for the following :",source:"@site/docs/dev-resources/Interfaces/ISocket.md",sourceDirName:"dev-resources/Interfaces",slug:"/dev-resources/Interfaces/ISocket",permalink:"/dev-resources/Interfaces/ISocket",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"IPlug",permalink:"/dev-resources/Interfaces/IPlug"},next:{title:"ISwitchboard",permalink:"/dev-resources/Interfaces/ISwitchboard"}},c={},d=[],u={toc:d},l="wrapper";function p(e){let{components:n,...t}=e;return(0,i.kt)(l,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Required by Plugs for the following : "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Connect to Socket "),(0,i.kt)("li",{parentName:"ol"},"Sending outbound messages "),(0,i.kt)("li",{parentName:"ol"},"Calculating message delivery fees on-chain")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.19;\n\nimport "./ITransmitManager.sol";\nimport "./IExecutionManager.sol";\n\n/**\n * @title ISocket\n * @notice An interface for a cross-chain communication contract\n * @dev This interface provides methods for transmitting and executing messages between chains,\n * connecting a plug to a remote chain and setting up switchboards for the message transmission\n * This interface also emits events for important operations such as message transmission, execution status,\n * and plug connection\n */\ninterface ISocket {\n    /**\n     * @notice A struct containing fees required for message transmission and execution\n     * @param transmissionFees fees needed for transmission\n     * @param switchboardFees fees needed by switchboard\n     * @param executionFee fees needed for execution\n     */\n    struct Fees {\n        uint128 transmissionFees;\n        uint128 executionFee;\n        uint128 switchboardFees;\n    }\n\n    /**\n     * @title MessageDetails\n     * @dev This struct defines the details of a message to be executed in a Decapacitor contract.\n     */\n    struct MessageDetails {\n        // A unique identifier for the message.\n        bytes32 msgId;\n        // The fee to be paid for executing the message.\n        uint256 executionFee;\n        // The min amount of gas that can be used to execute the message.\n        uint256 minMsgGasLimit;\n        // The extra params which might provide msg value and additional info needed for message exec\n        bytes32 executionParams;\n        // The payload data to be executed in the message.\n        bytes payload;\n    }\n\n    /**\n     * @title ExecutionDetails\n     * @dev This struct defines the execution details\n     */\n    struct ExecutionDetails {\n        // packet id\n        bytes32 packetId;\n        // proposal count\n        uint256 proposalCount;\n        // gas limit needed to execute inbound\n        uint256 executionGasLimit;\n        // proof data required by the Decapacitor contract to verify the message\'s authenticity\n        bytes decapacitorProof;\n        // signature of executor\n        bytes signature;\n    }\n\n    /**\n     * @notice emits the status of message after inbound call\n     * @param msgId msg id which is executed\n     */\n    event ExecutionSuccess(bytes32 msgId);\n\n    /**\n     * @notice emits the config set by a plug for a remoteChainSlug\n     * @param plug address of plug on current chain\n     * @param siblingChainSlug sibling chain slug\n     * @param siblingPlug address of plug on sibling chain\n     * @param inboundSwitchboard inbound switchboard (select from registered options)\n     * @param outboundSwitchboard outbound switchboard (select from registered options)\n     * @param capacitor capacitor selected based on outbound switchboard\n     * @param decapacitor decapacitor selected based on inbound switchboard\n     */\n    event PlugConnected(\n        address plug,\n        uint32 siblingChainSlug,\n        address siblingPlug,\n        address inboundSwitchboard,\n        address outboundSwitchboard,\n        address capacitor,\n        address decapacitor\n    );\n\n    /**\n     * @notice registers a message\n     * @dev Packs the message and includes it in a packet with capacitor\n     * @param remoteChainSlug_ the remote chain slug\n     * @param minMsgGasLimit_ the gas limit needed to execute the payload on remote\n     * @param payload_ the data which is needed by plug at inbound call on remote\n     */\n    function outbound(\n        uint32 remoteChainSlug_,\n        uint256 minMsgGasLimit_,\n        bytes32 executionParams_,\n        bytes32 transmissionParams_,\n        bytes calldata payload_\n    ) external payable returns (bytes32 msgId);\n\n    /**\n     * @notice executes a message\n     * @param executionDetails_ the packet details, proof and signature needed for message execution\n     * @param messageDetails_ the message details\n     */\n    function execute(\n        ISocket.ExecutionDetails calldata executionDetails_,\n        ISocket.MessageDetails calldata messageDetails_\n    ) external payable;\n\n    /**\n     * @notice seals data in capacitor for specific batchSize\n     * @param batchSize_ size of batch to be sealed\n     * @param capacitorAddress_ address of capacitor\n     * @param signature_ signed Data needed for verification\n     */\n    function seal(\n        uint256 batchSize_,\n        address capacitorAddress_,\n        bytes calldata signature_\n    ) external payable;\n\n    /**\n     * @notice proposes a packet\n     * @param packetId_ packet id\n     * @param root_ root data\n     * @param switchboard_ The address of switchboard for which this packet is proposed\n     * @param signature_ signed Data needed for verification\n     */\n    function proposeForSwitchboard(\n        bytes32 packetId_,\n        bytes32 root_,\n        address switchboard_,\n        bytes calldata signature_\n    ) external payable;\n\n    /**\n     * @notice sets the config specific to the plug\n     * @param siblingChainSlug_ the sibling chain slug\n     * @param siblingPlug_ address of plug present at sibling chain to call inbound\n     * @param inboundSwitchboard_ the address of switchboard to use for receiving messages\n     * @param outboundSwitchboard_ the address of switchboard to use for sending messages\n     */\n    function connect(\n        uint32 siblingChainSlug_,\n        address siblingPlug_,\n        address inboundSwitchboard_,\n        address outboundSwitchboard_\n    ) external;\n\n    /**\n     * @notice deploy capacitor and decapacitor for a switchboard with a specified max packet length, sibling chain slug, and capacitor type.\n     * @param siblingChainSlug_ The slug of the sibling chain that the switchboard is registered with.\n     * @param maxPacketLength_ The maximum length of a packet allowed by the switchboard.\n     * @param capacitorType_ The type of capacitor that the switchboard uses.\n     * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_`\n     */\n    function registerSwitchboardForSibling(\n        uint32 siblingChainSlug_,\n        uint256 maxPacketLength_,\n        uint256 capacitorType_,\n        address siblingSwitchboard_\n    ) external returns (address capacitor, address decapacitor);\n\n    /**\n     * @notice Emits the sibling switchboard for given `siblingChainSlug_`.\n     * @dev This function is expected to be only called by switchboard.\n     * @dev the event emitted is tracked by transmitters to decide which switchboard a packet should be proposed on\n     * @param siblingChainSlug_ The slug of the sibling chain\n     * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_`\n     */\n    function useSiblingSwitchboard(\n        uint32 siblingChainSlug_,\n        address siblingSwitchboard_\n    ) external;\n\n    /**\n     * @notice Retrieves the packet id roots for a specified packet id.\n     * @param packetId_ The packet id for which to retrieve the root.\n     * @param proposalCount_ The proposal id for packetId_ for which to retrieve the root.\n     * @param switchboard_ The address of switchboard for which this packet is proposed\n     * @return The packet id roots for the specified packet id.\n     */\n    function packetIdRoots(\n        bytes32 packetId_,\n        uint256 proposalCount_,\n        address switchboard_\n    ) external view returns (bytes32);\n\n    /**\n     * @notice Retrieves the minimum fees required for a message with a specified gas limit and destination chain.\n     * @param minMsgGasLimit_ The gas limit of the message.\n     * @param remoteChainSlug_ The slug of the destination chain for the message.\n     * @param plug_ The address of the plug through which the message is sent.\n     * @return totalFees The minimum fees required for the specified message.\n     */\n    function getMinFees(\n        uint256 minMsgGasLimit_,\n        uint256 payloadSize_,\n        bytes32 executionParams_,\n        bytes32 transmissionParams_,\n        uint32 remoteChainSlug_,\n        address plug_\n    ) external view returns (uint256 totalFees);\n\n    /// return instance of transmit manager\n    function transmitManager__() external view returns (ITransmitManager);\n\n    /// return instance of execution manager\n    function executionManager__() external view returns (IExecutionManager);\n}\n')))}p.isMDXComponent=!0}}]);