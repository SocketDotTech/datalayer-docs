"use strict";(self.webpackChunkdatalayer_docs=self.webpackChunkdatalayer_docs||[]).push([[4918],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,f=d["".concat(c,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const o={id:"protocol-design",title:"Protocol Design",sidebar_position:1},i=void 0,s={unversionedId:"Learn/protocol-design",id:"Learn/protocol-design",title:"Protocol Design",description:"Introduction",source:"@site/docs/Learn/protocol-architecture.md",sourceDirName:"Learn",slug:"/Learn/protocol-design",permalink:"/Learn/protocol-design",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"protocol-design",title:"Protocol Design",sidebar_position:1},sidebar:"defaultSidebar",previous:{title:"Glossary",permalink:"/Learn/glossary"},next:{title:"Lifecycle",permalink:"/Learn/lifecycle"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Architecture",id:"architecture",level:2}],p={toc:l},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Socket is an on-chain contract that transmits payloads between chains. When a payload is sent by a contract to Socket deployed locally on that chain, Socket compresses it into a Packet - a cryptographic hash representing 1000s of payloads that want to be sent to another chain."),(0,r.kt)("p",null,'Packet delivery is carried out by off-chain participants called "Transmitters". Much like a sequencer in an L2, the transmitter is responsible for delivering a bunch of payloads from one-chain to another. However, an important difference is, Transmitter first signs and seals a packet on the source side and then submits the packet on the destination side. The packet, along with the transmitter\u2019s signature, is now available on Socket on both chains '),(0,r.kt)("p",null,"On the destination chain, contracts called ",(0,r.kt)("a",{parentName:"p",href:"./Learn/Components/Switchboards"},(0,r.kt)("inlineCode",{parentName:"a"},"Switchboards"))," allow protocols to select context around how & when a delivered payload should be processed. Socket appoints executors to process the message payload only if it meets conditions on the protocol selected Switchboard. For example, accept payload after timeout of 2 hours, accept payload if native bridge confirms etc."),(0,r.kt)("p",null,"There are several components in the Socket protocol that work together to make the above happen."),(0,r.kt)("img",{src:"/img/BroadArchitecture.png",width:"700px"}),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"Socket is built in a modular fashion with various layers with defined APIs/Interfaces between them which allows developers the ability to leverage the software-stack in different and more efficent ways depending on their application context. "),(0,r.kt)("p",null,"The protocol consists of four key layers:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Application Layer"),": This layer consists of ",(0,r.kt)("inlineCode",{parentName:"li"},"Plugs"),", which are smart contract applications built to interact with Socket. Plugs follow a specified API and communicate through deployed Socket instances between any two supported chains. The core Socket contract functions as an on-chain endpoint that sends and receives payloads between chains. As applications send payloads through Plugs, Socket compresses them into cryptographic hashes called ",(0,r.kt)("inlineCode",{parentName:"li"},"Packets"),", which represent thousands of payloads across apps."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Delivery Layer"),": The delivery layer handles message batching and packet delivery between chains. ",(0,r.kt)("a",{parentName:"li",href:"/Learn/Components/Capacitors"},(0,r.kt)("inlineCode",{parentName:"a"},"Capacitor"))," contracts in Socket store packets until they are ready to be sealed. Transmitters, off-chain actors deliver packets between chains by committing with their signatures on both source and destination chains. This ensures transparency and accountability. The verification layer can use this to build trustless verification schemes. Permissionless and transparent message delivery  allows for an efficient marketplace for message delivery."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Verification Layer"),": The layer for packet and message verification through ",(0,r.kt)("a",{parentName:"li",href:"/Learn/Components/Switchboards"},(0,r.kt)("inlineCode",{parentName:"a"},"Switchboards")),". These customizable verification modules allow developers to define custom conditions for packet acceptance or rejection, offering flexibility in terms of security and performance. On the destination chain, contracts called Switchboards enable apps to choose the context in which a delivered payload is processed. Socket processes the payload only if it meets the conditions specified by the app-selected Switchboard, such as accepting payloads after a 2-hour timeout or confirming payloads through a native rollup bridge. Permissionlessness and modularity at the verification layer is a core advantage and design principle for Socket. "),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Execution Layer"),": This layer handles message execution on the destination chain after verification, allowing third-party relayers like Gelato to handle execution, or for applications or users to execute their own messages with various re-try mechanisms etc.")),(0,r.kt)("img",{src:"/img/dl-layers.png"}),(0,r.kt)("p",null,"Learn more about individual compoenents in ",(0,r.kt)("a",{parentName:"p",href:"/Learn/Components/Capacitors"},"Components")," and ",(0,r.kt)("a",{parentName:"p",href:"/Learn/OffChain-Agents"},"Offchain Agents"),"."))}h.isMDXComponent=!0}}]);